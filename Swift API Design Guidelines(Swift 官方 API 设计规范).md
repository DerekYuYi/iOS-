# 内容列表

- [基本原理](基本原理)
- [命名](命名)
	- [提高清晰性用法](提高清晰性用法)
	- [力求流利性用法](力求流利性用法)
	- [用好术语](用好术语)
- [惯例](惯例)
	- [通用惯例](通用惯例)
	- [参数](参数)
	- [参数标签](参数标签)
- [特殊说明](特殊说明)
- [原文链接] (参考原文) 


# 基本原理

- **清晰性的使用**是你最重要的目标. 方法和属性等实体声明一次但是使用多次. 设计 APIs 可以清晰和准确的使用这些实体. 当我们评估一个设计时, 阅读一个声明几乎不够. 总是检查一个用例以确保它在上下文中看起来清晰.

- **清晰性比简洁性更重要**. 尽管 Swift 代码可以小巧紧凑, 但是使用最少的字符来实现尽可能小的代码, 不是目标. Swift 代码的简洁性对强类型系统会产生副作用, 自然而然也会减少样板文件代码.

- **为每个声明写文档注释**. 通过编写文档能够利用一些权限, 比如 Xcode 的自带提示

	>  如果你很难轻易的描述某个 API 的功能, **那你可能设计了一个错误的API.**
	
	 - **使用 Swift 的 [Markdown](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/).**
	 
	 - **从摘要开始**. 摘要描述整个被描述的实体. 通常, 可以从某个实体的声明和摘要来理解 API.
	 
	 >```Swift
	 /// Returns a "view" of `self` containing the same elements in
	 /// reverse order.
	 func reversed() -> ReverseCollection
	 ```
		
	 	- **专注于摘要**.  这是最重要的部分. 许多优秀的文档也不过是由好的摘要组成.
	 	
	 	- **尽可能使用句子片段**. 以句号结束.  不要使用完整的句子.

	 	- **描述函数和方法是干什么, 返回什么**. 删除空效果和 `Void` 返回:

	 		```Swift
			/// Inserts `newHead` at the beginning of `self`.
			mutating func prepend(_ newHead: Int)
			
			/// Returns a `List` containing `head` followed by the elements
			/// of `self`.
			func prepending(_ head: Element) -> List    
			 
			/// Removes and returns the first element of `self` if non-empty;
			/// returns `nil` otherwise.
			mutating func popFirst() -> Element?
			```
			Note:   少数情况如 `popList`, 摘要是由多个句子片段组成, 中间使用分号分开.
	 	
	 	- **描述下标访问的内容**:

	 		>```Swift
		 	/// Accesses the `index`th element.
		 	subscript(index: Int) -> Element { get set }
		 	```
		 	
	 	- **描述初始化创建的内容**:

	 		>```Swift
		 	/// Creates an instance containing `n` repetitions of `x`.
		 	init(count n: Int, repeatedElement x: Element)
		 	```
	 	
	 	- 对于其他声明, **描述声明的实体是什么**:

	 		```Swift
	 		/// A collection that supports equally efficient insertion/removal
	 		/// at any position.
	 		struct List {

			  /// The element at the beginning of `self`, or `nil` if self is
			  /// empty.
			  var first: Element?
			  ...
	 		```

	- **作为选择, 使用一个或者多个段落和项目符号项**. 段落间使用空行和完整的句子分开.
	
		```Swift
		/// Writes the texual representation of each 
		/// element of `items` to the standard output.
		///
		/// The textual representation for each item `x`
		/// is generated by the expression `String(x)`.
		///
		/// - Parameter separator: text to be printed between items.
		/// - Parameter terminator: text to be printed at the end.
		///
		/// - Note: To print without a trailing 
		/// newline, pass `terminator: ""`
		///
		/// - SeeAlso: `CustomDebugStringConvertible`,
		/// `CustomStringConvertible`、`debugPrint`.
		public func print(
  		    _ items: Any..., separator: String = " ", terminator: String = "\n")
		```
	 	
	 	- **使用可识别的[符号标记元素](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SymbolDocumentation.html#//apple_ref/doc/uid/TP40016497-CH51-SW1)来添加其他信息.**
	 	
	 	- 使用[符号命令语法](https://swift.org/documentation/api-design-guidelines/)来了解并使用可识别项目符号项. 热门的开发者工具如 Xcode 对如下关键字开头的项目符号项做了特殊处理:

	 		| [Attention](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html)  | [Author](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Author.html) | [Authors](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Authors.html) |  [Bug](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Bug.html) |
	 		|  ----    |  --- | ---- | ---- |
	 		| [Complexity](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Complexity.html)  | [Copyright](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Copyright.html) | [Date](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Date.html) | [Experiment](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Experiment.html) |
	 		| [Important](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Important.html)  | [Invariant](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Invariant.html) | [Note](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Note.html) | [Parameter](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameter.html) |
	 		| [Parameters](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Parameters.html)  | [Postcondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Postcondition.html) | [Precondition](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Precondition.html) | [Remark](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Remark.html) |
	 		| [Requires](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Requires.html) | [Returns](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Returns.html) | [SeeAlso](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/SeeAlso.html) | [Since](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Since.html) |
	 		| [Throws](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Throws.html)  | [ToDo](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/ToDo.html) | [Version](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Version.html) | [Warning](https://developer.apple.com/library/archive/documentation/Xcode/Reference/xcode_markup_formatting_ref/Warning.html) |
		 	
		 	


# 命名

## 提高清晰性用法

- **为了避免阅读某处命名的代码有歧义, 为命名包括所有必要的单词.**

	例如方法: 某个集合内, 移除指定位置的元素
	
	
	```Swift
	extension List {
	  public mutating func remove(at position: Index) -> Element
	}
	employees.remove(at: x)
	```
	
	如果我们删除单词 `at`, 这就可能暗示读者该方法是用来搜索在 `x` 元素然后移除 `x` 元素, 而不是使用 `x` 去表示将要移除元素的位置.
	
	>```Swift
	employees.remove(x) // unclear: are we removing x?
	```

- **省略不必要的单词**. 每个名字中的每个单词都应该在用户使用地方明确传达信息. 

	许多单词可能被要求说明意图或者消除歧义, 但是应该删除读者已经读到的重复信息. 尤其是, 省略仅仅是重复类型信息的单词.
	
	>```Swift
	public mutating func removeElement(_ member: Element) -> Element?
	
	allViews.removeElement(cancelButton)
	```

	在上面这种情况下, 单词 `Element` 在调用的地方没有任何突出的内容. 这个 API 如果改成下面会更好:
	
	```Swift
	public mutating func remove(_ member: Element) -> Element?
	
	allViews.remove(cancelButton)
	```
	
	有时候重复类型信息有必要用来避免歧义, 但是一般来说, 更好的办法是使用单词描述参数角色, 而不是参数类型. 详情可以看下一条.

- **根据变量, 参数和关联类型的角色来命名**, 而不是它们的类型约束.

	>```Swift
	var string = "Hello"
	protocol ViewController {
		associatedtype ViewType : View
	}
	class ProductionLine {
		func restock(from widgetFactory: WidgetFactory)
	}
	```
	
	以这种方式调整类型名将无法优化清晰度和和表现力. 相反,  努力选择一个表达实体*角色*的名称.
	
	```Swift
	var greeting = "Hello"
	protocol ViewController {
		associatedtype ContentView: View
	}
	class ProductionLine {
		func restock(from supplier: WidgetFactory)
	}
	```
	
	如果关联类型和协议约束紧密相连, 这个协议名即表现为其角色,  可以通过添加在 `Protocol` 在协议名之后来避免冲突.
	
	```Swift
	protocol Sequence {
		associatedType Iterator: IteratorProtocol
	}
	protocol IteratorProtocol { ... }
	```
	
- **补充弱引用信息**, 让参数角色更加清晰. 

	当一个参数类型是 `NSObject`, `Any`, `AnyObject` 和一个基本类型如 `Int` 或者 `String` 时, 当正在使用它们时, 类型信息和内容有可能无法充分表达意图. 在下面这个例子中, 声明可能很清晰, 但是使用时却存在歧义.
	
	>```Swift
	func add(_ observer: NSObject, for keyPath: String)
	grid.add(self, for graphic) // vague
	```
	
	为了确保表意清晰, **在每个弱类型参数前面加上一个描述其角色的名词**:
	
	```Swift
	func addObserver(_ observer: NSObject, forKeyPath path: String)
	grid.addObserver(self, forKeyPath: graphics) // clear
	```
	

## 力求流利性用法

- **推荐使用方法和函数名称, 这个方法和函数名称让使用场景由英语短语组成**.

	推荐使用:

	```Swift
	x.insert(y, at: z) 				"x, insert y at z"
	x.subViews(havingColor: y).    "x's subviews having color y"
	x.capitalizingNouns()			"x, capitalizing nouns"
	```
	
	不推荐使用:
	
	```Swift 
	x.insert(y, position: z)
	x.subViews(color: y)
	x.nounCapitalize()
	```
	
	当第一个或者第二个参数对调用不重要时, 流畅度在第一个或第二个参数降低是可以接受的.
	
	```Swift
	AudioUnit.instantiate(
		with: description,
		options: [.inProgress], completionHandler: stopProgressBar)
	```
	
- **工厂方法的名字以 “make”开头**, 例如 x.makeIterator().

- 初始化方法和工厂方法调用的第一个参数不应该由基础名字开头的短语组成, 例如 `x.makeWidget(cogCount: 47)`

	例如, 这些调用的第一个参数不作为基本名字短语的一部分读取: (推荐)
	
	```Swift
	let foreground = Color(red: 32, green: 64, blue: 128)
	let newPart = factory.makeWidget(gears: 42, spindles: 14)
	let ref = Link(target: destination)
	```
	
	在下面, api 的作者试图用第一个参数创造语法上的连续性. (不可取)
	
	```Swift
	let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)
	let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)
	let ref = Link(to: destination)
	```
	
	实际使用中, 第一个参数会有一个 label 标签, 除非正在执行类型转换操作.
	
	```Swift
	let rgbForeground = RGBColor(cmykForeground)
	```
	
- **根据其副作用命名函数**
	
	- 没有副作用的命名应该读作名词短语, 例如 `x.distance(to: y)`, `i.successor()`.
	
	- 有副作用的命名应该读作祈使动词短语, 例如 `print(x)`, `x.sort()`, `x.append(y)`.

	- **始终命名可变/不可变方法对**.  可变方法常常有一个语义相同的不可变方法, 但是不可变方法返回新值而不是就地更新实例.

		- 当某个操作由动词描述, 使用这个动词的祈使动词作为可变方法名称, 并且通过在该动词添加 `ed` 或者 `ing` 后缀来作为对应不可变方法.

			|  Mutating | Nonmutating |
			|   ----     |      ----------      | 
			|  x.sort()       |    z = x.sorted() |
			|  x.append(y) |  z = x.appending(y)  |
			
			- 推荐使用动词的过去分词作为不可变方法的名称(通常是在末尾添加 `ed`).

				```Swift
				/// Reverses `self` in-place.
				mutating func reverse()
				
				/// Returns a reversed copy of `self`.
				func reversed() -> Self
				...
				x.reverse()
				let y = x.reversed()
				```
			    
			- 当添加 `ed` 不是一个正常语法时,  可以使用动词的现代分词(通常添加 `ing`).

			 	```Swift
			 	/// Strips all the newlines from `self`
			 	mutating func stripNewlines()
			 	
			 	/// Returns a copy of `self` with all the newlines stripped.
			 	func strippingNewlines() -> String
			 	...
			 	s.stripNewlines()
			 	let oneLine = t.strippingNewlines()
			 	```
			 	
			- 当某个操作被描述为名词时, 使用名词作为不可变方法, 在该名词前面加上 `form` 前缀作为对应可变方法.

				|	Nonmutating    |   Mutating   |
				|	-------	    |	------		|
				|	x = y.union(z)   |   y.formUnion(z) |
				|	j = c.successor(i) |	c.formSuccessor(&i)   |
				
			- 当使用不可变实体时, **返回 Bool 的方法和属性对于接受者来说, 应该被读作断言**. 例如, `x.isEmpty`, `line1.intersects(line2).`

			- **描写某物的协议应该是名词**. 例如 `Collection`.

			- **描写某种能力的协议应该使用 `able`, `ible`, 或者 `ing` 作为后缀**. (例如 `Equatable`, `ProgressReporting`).
			
			- **类型, 属性, 变量和常量**应该使用名词命名.

## 用好术语

- **如果一个更常见的词也能表达意思, 就不要使用晦涩难懂的词**. 如果 “皮肤” 可以表达你的意思, 就不要使用 “表皮”. 术语是一种必不可少的交流工具,  但是仅仅应用在某些重要意义, 这些重要意义不用术语表达就会失去本身意思.

- 如果你使用了术语, 那么请坚持使用既定的意义.

- **避免缩写.** 你使用的任何缩写应该轻易从网上搜索到.

- **接受先例.** 

	命名连续的数据结构, 使用 `Array` 比使用 `List` 要好. 尽管初学者可能对 `List` 理解更深. 数组是现代计算机中的基本.
	
	在某个特殊编程领域内, 比如数学, 一个很早的术语如 `sin(x)` 比它的解释短语例如 `verticalPositionOnUnitCircleAtOriginOfEndOfRadiusWithAngle(x)` 要更易理解. 在这种情况下, 先例规则优先于**避免缩写**规则.

		 	
# 惯例

## 常用惯例

- **记录时间复杂度不是 O(1) 的计算属性的复杂度.**

大家通常认为, 属性访问不需涉及重要的运算, 因为他们把存储属性当作想象的模型. 当有可能违背这种假设时, 一定要提醒他们.

- **与自由函数相比, 更喜欢方法和属性.** 自由函数仅仅使用在以下特殊情况中:

	1. 没有明显的 `self`:
	
		```Swift
		min(x, y, z)
		```
		
	2. 当函数是无约束泛型时:

		```Swift
		print(x)
		```
		
	3. 当函数的语法是基于已有域声明的一部分时:

		```Swift
		sin(x)
		```
	
- **遵循案例惯例.** 类型和协议的名字遵循 `驼峰大写`, 其他遵循 `驼峰小写`.

- **方法可以共享一个基础名字.** 当方法都有基本的意思, 或者他们在一个明显的领域操作.

	例如, 鼓励下面例子的写法, 因为这些方法大体上做着相同的事:
	
	```Swift
	extension Shape {
		/// Returns `true` iff `other` is within the area of `self`.
		func contains(_ other: Point) -> Bool { ... }
		
		/// Returns `true` iff `other` is entirely within the area of `self`.
		func contains(_ other: Shape) -> Bool { ... }
		
		/// Returns `true` iff `other` is within the area of `self`.
		func contains(_ other: LineSegment) -> Bool { ... } 
	}
	```
  
     由于几何类型和集合属于不同的领域, 所以像下面的写法也是被允许的:

	```Swift
	extension Collection where Element : Equatable {
		/// Returns `true` iff `self` contains an element equal to 
		/// `sought`. 
		func contains(_ sought: Element) -> Bool { ... } 
	}
	```
	 
	但是, 下面这些 `index` 方法拥有不同的语义, 应该使用不同的命名:
	
	```Swift
	extension DataBase {
		/// Rebuilds the datebase's search index
		func index() { ... }
		
		/// Returns the `n`th row in the given table.
		func index(_ n: Int, inTable: TableID) -> TableRow { ... }
	}
	```
	
## 参数

- **选择参数名称以便提供文档.** 尽管参数名称在使用时不会出现在一个函数和方法中, 但是他们确实扮演一个解释者的角色.

	选择参数名称让文档更易阅读. 例如, 下面参数名字让文档读起来更自然:
	
	```Swift
	/// Return an `Array` containing the elements if `self`
	/// that satisfy `predicate`.
	func filter(_ predicate: (Element) -> Bool) -> [Generator.Element]
	
	/// Replace the given `subRange` of elements with `newElements`.
	mutating func replaceRange(_ subRange: Range, with newElements: [E])
	```
		
	但是, 下面的名字让文档令人费解, 并且显得不合语法:
	
	```Swift
	/// Return an `Array` containing the elements of `self`
	/// that satisfy `includedInResult`.
	func filter(_ includedInResult: (Element) -> Bool) -> [Generator.Element]
	
	/// Replace the range of elements indicated by `r` with 
	/// the contents of `with`.
	mutating func replaceRange(_ r: Range, with: [E])
	```

- 在简化常用功能时**利用默认参数**. 具有单个常用值的任何参数都是默认值的候选参数.

	默认参数通过隐藏不相关的信息来提高可读性. 例如:
	
	```Swift
	let order  = lastName.compare(
	  royalFamilyName, options: [], range: nil, locale: nil)
	```
	
	可以写得更加简单:
	
	```Swift
	let order = lastName.compare(royalFamilyName)
	```
	
	默认参数通常比使用方法簇更可取, 因为它们更能帮助理解 API.
	
	```Swift
	extension String {
		/// ...description...
		public func compare(
			_ other: String, options: CompareOptions = [],
			range: Range? = nil, locale: Locale? = nil
		) -> Ordering
	}
	``` 
	
	上面这个方法可能不简单, 但是它肯定比这样写更加容易:
	
	```Swift
	/// ...description 1...
	public func compare(_ other: String) -> Ordering
	
	/// ...description 2...
	public func compare(_ other: String, options: CompareOptions) -> Ordering
	
	/// ...description 3...
	public func compare(_ other: String, options: CompareOptions, range: Range) -> Ordering
	
	/// ...description 4...
	public func compare(
		_ other: String, 
		options: CompareOptions, 
		range: Range, 
		locale: Locale) -> Ordering
	```

- **更倾向于在参数列表的末尾定位默认参数.** 非默认参数通常对某个方法的声明是完全必要的, 当方法被调用时, 总是一个稳定的初始化样式.

## 参数标签

> ```Swift
func move(from start: Point, to end: Point)
x.move(from: x, to: y)
```

 - **当无法有效区分参数时, 忽略所有标签**, 例如 `min(number1, number2), zip(sequence1, sequence2)`.
 
 - **在执行保值类型转换的初始化函数中, 忽略第一个参数标签.** 例如 `Int64(someUInt32)`

	第一个参数总是转换的来源值.
	
 	```Swift
 	extension String {
 	  	// Convert `x` into its textual repreentation in the given radix
 		init(_ x: BigInt, radix: Int = 10)
 	}
 	
	text = "The value is:"
	text += String(veryLargeNumber)
	text += " and in hexadecimal, it's"
	text += String(veryLargeNumber, radix: 16)
 	```
 	
 - **当一个参数构成介词短语的一部分时, 给该参数加一个参数标签.** 参数标签应该以介词开头, 例如 `x.removeBoxes(havingLength: 12)`.

   	一个例外就是当前两个参数是某个抽象概念的一部分. 比如:
   	
   	```Swift
  	a.move(toX: b, y: c)
   	a.fade(fromRed: b, green: c, blue: d)
   	```
   	
 	在这种情况下, *在介词后面加上标签*, 来保持抽象概念清晰.
 	
 	```Swift
 	a.moveTo(x: b, y: c)
 	a.fadeFrom(red: b, green: c, blue: d)
 	```
 	
 - **相反, 当第一个参数有是正常语法短语的一部分时, 忽略该参数标签,** 例如: `x.addSubview(y)`

   	这条准则也是暗示如果第一个标签不是正常语法短语的一部分时, 应该给该参数加标签.
   	
   	```Swift
   	view.dismiss(animated: false)
   	let text = words.split(maxSplits: 12)
   	let studentByName = students.sorted(isOrderedBefore: Student.namePrecedes)
  	``` 
  	
  	记住短语表意清晰很重要. 下面例子中虽然符合语法, 但是表意错误.
  	
  	```Swift
  	view.dismiss(false)  // Don't dismiss? Dismiss a Bool?
  	words.split(12)        // Split the number 12?
  	```
  	
 - **标记其他所有参数.**


# 特殊说明

- **在 API 中标记元组成员和闭包参数**.

	```Swift
	/// Ensure that we hold uniquely-referenced storage for at least
	/// `requestedCapacity` elements.
	///
	/// If more storage is needed, `allocate` is called with
	/// `byteCount` equal to the number of maximally-aligned
	/// bytes to allocate.
	///
	/// - Returns:
	///    -  reallocated: `true` iff a new block of memory
	///     was allocated.
	///    - capacityChanged: `true` iff `capacity` was updated.
	mutating func ensureUniqueStorage(
	     minimumCapacity requestedCapacity: Int,
	     allocate: (_ byteCount: Int) -> UnsafePointer<Void>
	) -> (reallocated: Bool, capacityChanged: Bool)
	```
	 
 - **多注意无约束多态性(比如 `Any`, `AnyObject`和泛型)**以避免 重载集 中的歧义.

 	例如, 下面的重载集:
 	
 	```Swift
 	struct Array {
	 	/// Inserts `newElement` at `self.endIndex`.
	 	public mutating func append(_ newElement: Element)
	 	
	 	/// Inserts the contents of `newElements`, in order, at
	 	/// `self.endIndex`.
	 	public mutating func append(_ newElements: S) where S.Generator.Element == Element
 	}
 	```
 	
 	如果这样使用, 就会引起歧义:
 	
 	```Swift
 	var values: [Any] = [1, "a"]
 	values.append([2, 3, 4]) // [1, "a", [2, 3, 4]] or [1, "a", 2, 3, 4]?
 	```
 	
 	为了消除歧义,  这样命名第二个参数会更清晰.
 	
 	```Swift
 	Struct Array {
 		/// Inserts `newElement` at `self.endIndex`.
 		public mutating func append(_ newElement: Element)
 		
 		/// Inserts the contents of `newElements`, in order, at
  		/// `self.endIndex`.
 		public mutating func append(contentsOf newElements: S) where S.Generator.Element == Element
 	}
 	```
 	
 	注意新名称是如何更好地匹配文档注释. 在本例中, 编写文档注释的行为实际上引起了API作者的注意。
	
	
# 参考原文 

[API Design Guidelines](https://swift.org/documentation/api-design-guidelines/#argument-labels)